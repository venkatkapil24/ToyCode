        !********************************************************
        !*                      TOYCODE-1.0                     *
        !*                                                      *
        !*      A MD PLATFORM FOR TESTING ENHANCED              *
        !*      SAMPLING ALGORITHMS.                            *
        !*                                                      *
        !*      DEVELOPED BY VENKAT KAPIL                       *
        !*      CONTACT : venkat@iitk.ac.in                     *
        !*                                                      *
        !*      COPYRIGHT (C) 2014 VENKAT KAPIL                 *
        !*      SOME RIGHTS RESERVED.                           *
        !*                                                      *                                                       
        !********************************************************

	!THIS FILE CONTAINS SUBROUTINES THAT GOVERN DYNAMICS. 
	!THEY ARE AS FOLLOWS:
	!	*) GET_FORCEFIELD 
	!	*) INITIALIZE
	!	*) GET_FORCE
	!	*) GET_ENERGY_T
	!	*) GET_ENERGY_V
	!	*) GET_V_FF
	!	*) GET_V_BIAS
	!	*) GET_V_UMBR
	!	*) GET_ENERGY
	!	*) SCALE_VELOCITY
	!	*) EVOLVE
	!	*) THERMOSTAT
 
	!SUBROUTINE *) GET_FORCEFIELD
	!THIS SUBROUTINE TUNES THE FORCEFIELD PARAMETERS SO THAT AN EQULIBRIUM FREQUENCY OF APPROX. 2000/CM IS OBSERVED. 
	SUBROUTINE GET_FORCEFIELD
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
	USE FORCEFIELD
	IMPLICIT NONE
	INTEGER ITER1, ITER2
	!DYNAMICALLY ALLOCATES VARIABLES.
	ALLOCATE( V(NWELL+1), A(NWELL+1), RO(NDIM,NWELL+1) )
	!ASSIGNS THE WIDTH AND POTENTIAL TO EACH WELL.
	DO ITER1=1, NWELL
		V(ITER1) = DFLOAT(2) * BARRIER
		A(ITER1) = 2.0*PI*PI* MASS / V(ITER1) / 673.0D0 /673.0D0
	ENDDO
	!ASSIGNS LARGE POTENTIAL AND WIDTH TO THE LAST WELL SO THAT THE SYSTEM REMAINS BOUNDS.
	V(NWELL+1) = 5.0D0*V(NWELL)
	A(NWELL+1) = 0.10D0 * A(NWELL)  
	!SETS ALL THE COORDINATES EXCEPT THE FIRST TO ZERO. 
	DO ITER1=1,NDIM
		DO ITER2=1,NWELL+1
			RO(ITER1,ITER2) = 0.0D0
		ENDDO
	ENDDO
	IF( NWELL .EQ. 2 ) THEN
		V(2) = 0.75D0*V(1)
		RO(1,2) = 2.355D0 / DSQRT(A(2)) *DCOS(0.20D0)
		RO(2,2) = 2.355D0 / DSQRT(A(2)) *DSIN(0.20D0)
	ENDIF
!	!MODELS A SKEWED POTENTIAL.
	IF( NWELL .EQ. 3 ) THEN
		V(2) = V(1)
		V(3) = 1.0D0 * V(1)
		RO(1,2) = 2.55D0 / DSQRT(A(2)) *DCOS(0.0D0)
		RO(2,2) = 0.0D0
		RO(1,3) = 0.0D0
		RO(2,3) = 0.9D0 * 2.355D0 / DSQRT(A(2))
		RO(2,4) = RO(2,3) / 2.0D0
		RO(1,4) = 2.355D0 / DSQRT(A(2)) /2.0D0
	ENDIF
	!MODELS A DOUBLE WELL FLAT POTENTIAL.
	IF( NWELL .EQ. 4 ) THEN
		V(2) = V(1) *0.65D0
		V(3) = V(1) *0.65D0
		V(4) = V(1) *0.65D0
		A(2) = A(1) *0.3D0
		A(3) = A(1) * 0.30D0
		A(4) = A(1) *0.30D0
		RO(1,2) = 2.355D0 / DSQRT(A(2))
		RO(1,3) = RO(1,2) +1.5D0* DSQRT( 0.3010/A(3) )
		RO(1,4) = RO(1,3) +1.5D0* DSQRT( 0.3010/A(3) )
	ENDIF
	RO(1,NWELL+1) = RO(1,2) /2.0D0
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) INITIALIZE
	!THIS SUBROUTINE INITIALIZES THE DYNAMIC VARIABLES.
	SUBROUTINE INITIALIZE
        USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
	USE DYNAMICS_MOLDYN 
	IMPLICIT NONE
	INTEGER ITER1,ITER2, SEED
	REAL*8 SIGMA, GRAND, FORCE
	!CHOOSES MILLISECOND TIME SEED.
	CALL SYSTEM_CLOCK(SEED)
	CALL SRAND(SEED)
	IF (RESTART_MD .EQV. .FALSE. ) THEN
	!INITIALIZES TIME.
		TIME = 0.0D0
	!CALCULATES THE STANDARD DEVIATION OF BOLTZMAN DISTRIBUTION OF VELOCITY.
		SIGMA = DSQRT ( TEMP / MASS )
		CALL GET_GAUSSRAND( GRAND, SIGMA )
	!INITIALIZES POSITION AND VELOCITY.
		DO ITER1=1,NDIM
			POS(ITER1) = 0.0D0
			CALL GET_GAUSSRAND(GRAND, SIGMA )
			VEL(ITER1) = GRAND
        !INITIALIZES POSITION TO THE CENTRE OF THE UMBRELLA.
			IF( UMBR .EQV. .TRUE.) THEN
				DO ITER2=1,UMBR_DIM
               		         	IF( UMBR_COMP(ITER2) .EQ. ITER1 ) THEN 
						POS(ITER1) = UMBR_MEAN(ITER2)
                                	ENDIF
                        	ENDDO
			ENDIF
		ENDDO
	ELSE
	!OPENS MD_RESTART FILE.
		OPEN(UNIT=1, FILE='RESTART/RESTART_MOLDYN')
	!ASSIGNS POSITION.
		READ(1,*) (POS(ITER1), ITER1=1,NDIM)
	!ASSIGNS VELOCITY.
		READ(1,*) (VEL(ITER1), ITER1=1,NDIM)
	!ASSIGNS ACCLERATION.
		READ(1,*) (ACCL(ITER1), ITER1=1,NDIM)
	!ASSIGNS TIME.
		READ(1,*) TIME
	ENDIF
	CALL SCALE_VELOCITY
	!CALCULATES INITIAL ACCLERATION.
	DO ITER1=1,NDIM
		CALL GET_FORCE( FORCE, ITER1 )
		ACCL(ITER1) = FORCE / MASS
	ENDDO	
	!CALCULATES INITIAL ENERGY.
	CALL GET_ENERGY
	!PRINTS UMBRELLA POSITION.
	OPEN(UNIT=1, FILE = OUTPUTFILE, STATUS = 'OLD',
     &  POSITION = 'APPEND')
        IF( UMBR .EQV. .TRUE. ) THEN
                WRITE(1,*) 'UMBRELLA NO', UMBR_COUNT, ', AT',
     &          (POS(ITER1), ITER1=1,NDIM )
        ENDIF
	CLOSE(1)
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) GET_FORCE
	!THIS SUBROUTINE CALCULATES FORCE FROM FORCEFIELD, BIAS AND UMBRELLA.
	SUBROUTINE GET_FORCE( FORCE, COMP )
        USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
     	REAL*8 DUMMY, FORCE 
	INTEGER ITER1, ITER2, ITER3, COMP
	FORCE = 0.0D0
	!FINDS FORCE CONTRIBUTION EACH FIRST WELL.
	DO ITER3 = 1, NWELL + 1
		DUMMY=0.0D0
		DO ITER1=1,NDIM
			DUMMY = DUMMY + (POS(ITER1)-RO(ITER1,ITER3))*
     &			(POS(ITER1)-RO(ITER1,ITER3))
		ENDDO
		FORCE = FORCE  - 2.0D0*V(ITER3)*A(ITER3)*
     &		(POS(COMP)-RO(COMP,ITER3))*
     &		DEXP(-A(ITER3)*DUMMY)
	ENDDO
	!FINDS FORCE CONTRIBUTION FROM UMBRELLA.
	IF( UMBR .EQV. .TRUE. ) THEN
		DO ITER1=1, UMBR_DIM
			IF( COMP .EQ. UMBR_COMP(ITER1) ) THEN 
				FORCE = FORCE - UMBR_K(ITER1)*(POS(COMP)-
     &				UMBR_MEAN(ITER1))
			ENDIF
		ENDDO
	ENDIF
	!FINDS FORCE CONTRIBUTION FROM BIAS.
	IF( META .EQV. .TRUE. ) THEN
		DO ITER3 = 1,META_DIM
			IF( COMP .EQ. META_CV(ITER3) ) THEN
				DO ITER1 = 1,META_COUNT-1
					DUMMY=0.0D0
					DO ITER2 =1,META_DIM
						DUMMY = DUMMY + 
     &						(POS(META_CV(ITER2))-META_MEAN(ITER2,ITER1))*
     &						(POS(META_CV(ITER2))-META_MEAN(ITER2,ITER1))
					ENDDO
					FORCE = FORCE + META_HEIGHT(ITER1) / 
     &					META_WIDTH(ITER1)/META_WIDTH(ITER1) *
     &					(POS(COMP)-META_MEAN(ITER3,ITER1)) * 
     &					DEXP(-0.50D0*DUMMY/META_WIDTH(ITER1)/META_WIDTH(ITER1))
				ENDDO
			ENDIF
		ENDDO
	ENDIF
	CALL GET_ENERGY
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) GET_ENERGY_T
	!THIS SUBROUTINE CALCULATES KINETIC ENERGY.
	SUBROUTINE GET_ENERGY_T
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
	INTEGER ITER
	!FINDS TOTAL KINETIC ENERGY
	ENERGY_T=0.0D0
	DO ITER =1,NDIM
		ENERGY_T = ENERGY_T + 0.50D0*MASS*VEL(ITER)*VEL(ITER)
	ENDDO
	INST_TEMP = 2.0D0 * ENERGY_T/ DFLOAT(NDIM) * KO
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) GET_ENERGY_V
	!THIS SUBROUTINE CALCULATES POTENTIAL ENERGY.
	SUBROUTINE GET_ENERGY_V
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
	!CALCULATES POTENTIAL ENERGY CONTRIBUTION FROM FORCEFIELD, BIAS AND UMBRELLA.
	CALL GET_V_BIAS
	CALL GET_V_FF
	CALL GET_V_UMBR
	ENERGY_V = V_FF + V_BIAS + V_UMBR
	RETURN
	END SUBROUTINE

	!SUBROUITNE *) GET_V_FF
	!THIS SUBROUTINE CALCULATES THE POTENTIAL ENERGY CONTRIBUTION OF THE FORCE FIELD. 
	SUBROUTINE GET_V_FF  
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
	REAL*8 DUMMY
	INTEGER ITER1, ITER2
	!FINDS POTENTIAL ENERGY CONTRIBUTION FROM EACH WELL.
	V_FF = 0.0D0
	DO ITER1=1, NWELL+1
		DUMMY=0.0D0
		DO ITER2=1,NDIM
			DUMMY = DUMMY + (POS(ITER2)-RO(ITER2,ITER1))*
     &			(POS(ITER2)-RO(ITER2,ITER1))
		ENDDO
		V_FF = V_FF -1.0D0*V(ITER1)*DEXP(-A(ITER1)*DUMMY)
	ENDDO
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) GET_V_BIAS
	!THIS SUBROUTINE CALCULATES POTENTIAL ENERGY CONTRIBUTION FROM BIAS.
	SUBROUTINE GET_V_BIAS
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
	INTEGER ITER1, ITER2
	REAL*8 DUMMY
	V_BIAS =0.0D0
	DUMMY=0.0D0
	DO ITER1 = 1,META_COUNT-1
		DUMMY=0.0D0
		DO ITER2 =1,META_DIM
			DUMMY = DUMMY + (POS(META_CV(ITER2))-META_MEAN(ITER2,ITER1))*
     &			(POS(META_CV(ITER2))-META_MEAN(ITER2,ITER1))
        	ENDDO
        	V_BIAS = V_BIAS + META_HEIGHT(ITER1)*
     &		DEXP(-0.50D0*DUMMY/META_WIDTH(ITER1)/META_WIDTH(ITER1))
	ENDDO
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) GET_V_UMBR
	!THIS SUBTOUTINE CALCULATES THE POTENTIAL ENEGRY CONTRIBUTION FROM UMBRELLA.
	SUBROUTINE GET_V_UMBR
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
	INTEGER ITER
	!CALCULATES THE POTENTIAL ENERGY FOR ALL RESTRAINED COMPONENTS.
	V_UMBR = 0.0D0
	IF( UMBR .EQV. .TRUE.) THEN 
		DO ITER =1,UMBR_DIM
			V_UMBR = V_UMBR + 0.50D0 * UMBR_K(ITER) * 
     &			(POS(ITER) - UMBR_MEAN(ITER)) * (POS(ITER) - UMBR_MEAN(ITER))
		ENDDO
	ENDIF
	RETURN
	END SUBROUTINE
	!SUBROUTINE *) GET_ENERGY
	!THIS SUBROUTINE CALCULATES TOTAL ENERGY.
	SUBROUTINE GET_ENERGY
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
	!CALCULATES KINETIC AND POTENTIAL ENERGY
	CALL GET_ENERGY_T
	CALL GET_ENERGY_V
	ENERGY = ENERGY_T + ENERGY_V 
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) SCALE_VELOCITY
	!THIS SUBROUTINE TUNES VELOCITY TO TEMPERATURE.
	SUBROUTINE SCALE_VELOCITY
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
	IMPLICIT NONE
	REAL*8 DUMMY
	INTEGER ITER
	!FINDS SQUARE OF VELOCITY.
	DUMMY =0.0D0
	DO ITER=1,NDIM
		DUMMY = DUMMY + VEL(ITER)*VEL(ITER)
	ENDDO
	DO ITER =1,NDIM
		VEL(ITER) = VEL(ITER) * DSQRT( DFLOAT(NDIM)*
     &		TEMP/MASS/DUMMY )
	ENDDO
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) EVOLVE
	!THIS SUBROUTINE GOVERNS TIME EVOLUTION.
	!IT USES THE VELOCITY VERLET ALGORITHM.
	SUBROUTINE EVOLVE
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
	INTEGER ITER
	REAL*8 FORCE  
	REAL*8, DIMENSION(:), ALLOCATABLE	:: DUMMY
	ALLOCATE( DUMMY(NDIM) )
	!CALCULATES FULLSTEP POSITION.
	DO ITER=1,NDIM
		POS(ITER) = POS(ITER) + VEL(ITER)*DT + 
     &		0.50D0*ACCL(ITER)*DT*DT
	ENDDO
	!CALCULATES FULLSTEP ACCLERATION.
	DO ITER=1,NDIM
		CALL GET_FORCE(FORCE,ITER)
		DUMMY(ITER) = FORCE / MASS
	ENDDO
	!CALCULATES FULLSTEP VELOCITY.
	DO ITER=1,NDIM
		VEL(ITER) = VEL(ITER) + 
     &		0.50D0*(ACCL(ITER)+DUMMY(ITER))*DT
	ENDDO
	!CALCULATES FULLSTEP ACCLERATION.
        DO ITER=1,NDIM
                CALL GET_FORCE(FORCE,ITER)
                ACCL(ITER) = FORCE / MASS
        ENDDO
	!UPDATES TIME.
	TIME= TIME + DT
	DEALLOCATE(DUMMY)
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) THERMOSTAT
	!KEEPS THE TEMPERATURE IN CHECK.
	!IMPLEMENTS AN ANDERSON'S THERMOSTAT.
	SUBROUTINE THERMOSTAT
        USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
	INTEGER ITER, RANDOM_COMP
	REAL*8	GRAND, SIGMA
	!PARTICLE COLLIDES WITH THE BATH AND GETS A RANDOM VELOCITY.
	SIGMA = DSQRT ( TEMP / MASS )
	!SELECTS THE COMPONENT IN WHICH FORCE IS RECEIVED.
	RANDOM_COMP = RAND() * (NDIM+1)
        CALL GET_GAUSSRAND(GRAND, SIGMA )
        VEL(RANDOM_COMP) = GRAND
	!TUNES THE FINAL VELOCITY TO TEMPERATURE.
	CALL SCALE_VELOCITY
	RETURN
	END SUBROUTINE

