        !********************************************************
        !*                      TOYCODE-1.0                     *
        !*                                                      *
        !*      A MD PLATFORM FOR TESTING ENHANCED              *
        !*      SAMPLING ALGORITHMS.                            *
        !*                                                      *
        !*      DEVELOPED BY VENKAT KAPIL                       *
        !*      CONTACT : venkat@iitk.ac.in                     *
        !*                                                      *
        !*      COPYRIGHT (C) 2014 VENKAT KAPIL                 *
        !*      SOME RIGHTS RESERVED.                           *
        !*                                                      *                                                       
        !********************************************************

	!THIS FILE CONTAINS SUBROUTINES THAT GOVERN METADYNAMICS. 
	!THEY ARE AS FOLLOWS:
	!	*) META_INITIALIZE
	!	*) DUMP_TRIGGER
	!	*) DUMP
	!	*) GET_META_HEIGHT
	!	*) PRINT_FES

	!SUBROUTINE *)	META_INITIALIZE
	!THIS SUBROUTINE INITIALIZES METADYNAMICS PARAMETERS.
	SUBROUTINE META_INITIALIZE
	USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
	USE METADYN
	IMPLICIT NONE
	INTEGER ITER1, ITER2, FILESIZE, DUMMY1, IOSTATUS
	CHARACTER (LEN=50) FORMAT1
	IF( RESTART_META .EQV. .FALSE. ) THEN
	!FIND THE TOTAL NUMBER OF GAUSSIANS TO BE ADDED IN THE SIMULATION.
        	META_NMAX = META_N
	!DYNAMICALLY DEFINES META_MEAN, META_HEIGHT AND META_WIDTH.
		ALLOCATE( META_MEAN(NDIM,META_NMAX), META_HEIGHT(META_NMAX), 
     &		META_WIDTH(META_NMAX) )
	!INITIALIZES META_ITER AND META_TRIGGER
	META_ITER = 0
	META_TRIGGER = .TRUE.
	!CREATES THE EMPTY RESTART FILE.
	IF (UMBR .EQV. .FALSE.) THEN
		CALL CREATE_FILE('RESTART/RESTART_METDYN')
		OPEN( UNIT =1, FILE='RESTART/RESTART_METDYN', STATUS='OLD',
     &		POSITION = 'APPEND')
	WRITE(1,*) META_NMAX
	ENDIF
	!CREATES EMPTY CV FILE.
	CALL CREATE_FILE('METADYNAMICS/META_CV')
	CLOSE(1)

	ELSE
	!UPDATES METADYNAMICS INFORMATION AND RESTART FILE.
	OPEN( UNIT =2, FILE='RESTART/RESTART_METDYN_DUMMY', 
     &	STATUS='NEW' )
	!FIND THE TOTAL NUMBER OF GAUSSIANS TO BE ADDED IN THE SIMULATION.
		OPEN( UNIT =1, FILE='RESTART/RESTART_METDYN' )
		READ(1,*) META_NMAX
		META_NMAX = META_NMAX + META_N
		WRITE(2,*) META_NMAX
	!DYNAMICALLY INITIALIZES META_MEAN, META_HEIGHT AND META_WIDTH.
		ALLOCATE( META_MEAN(META_DIM,META_NMAX), META_HEIGHT(META_NMAX),
     &          META_WIDTH(META_NMAX) )
	!UPDATES META_MEAN, META_HEIGHT AND META_WIDTH FROM RESTART INFORMATION.
	!ALSO UPDATES THE RESTART FILE.
	META_COUNT=0
		ITER1 = 1
		DO
			READ(1,*, IOSTAT = IOSTATUS) DUMMY1, (META_MEAN(ITER2,ITER1), 
     &			ITER2 = 1, META_DIM), META_HEIGHT(ITER1), META_WIDTH(ITER2)
			IF( IOSTATUS .LT. 0 ) EXIT
			WRITE(2,*) DUMMY1, (META_MEAN(ITER2,ITER1),
     &			ITER2 = 1, META_DIM), META_HEIGHT(ITER1), META_WIDTH(ITER2)
			ITER1 = ITER1+1
			META_COUNT = META_COUNT + 1
		ENDDO
	ENDIF
	!INITIALIZES META_ITER AND META_TRIGGER
	META_ITER = 0
	META_TRIGGER = .TRUE.
	!CREATES THE RESTART FILE.
	CLOSE(1, STATUS = 'DELETE')
	CALL RENAME('RESTART/RESTART_METDYN_DUMMY',
     &	 ' RESTART/RESTART_METDYN') 
	!ALLOCATES BIAS.
	CALL CREATE_FILE( 'METADYNAMICS/BIAS' )
	ALLOCATE( BIAS(NBINS) )
	!SETS THE BIAS TO ZERO.
	DO ITER1=0, NBINS
		BIAS(ITER1) = 0.0D0
	ENDDO
	CT = 0.0D0
	RETURN
	END SUBROUTINE

	!SUBROUTINE *)	DUMP_TRIGGER
	!THIS SUBROUTINE CHECKS IF IT IS SUITABLE TO ADD A GAUSSIAN.
	SUBROUTINE DUMP_TRIGGER
	USE PARAM
        USE UMBRSAMP
        USE DYNAMICS_MOLDYN
        USE CONSTANTS
        USE FORCEFIELD
        USE METADYN
        IMPLICIT NONE
	REAL*8 DUMMY1, DUMMY2
	INTEGER ITER
	!FINDS THE TIME SINCE LAST GAUSSIAN WAS ADDED.
	DUMMY1 = TIME - META_ITER*DT 
	!FINDS THE DISTANCE OF THE CV FROM THE LAST GAUSSIAN MEAN.
	DUMMY2 = 0.0D0
	DO ITER = 1,META_DIM
		DUMMY2 = DUMMY2 + 
     &		(META_MEAN(ITER,META_COUNT)- POS(META_CV(ITER)))*
     &		(META_MEAN(ITER,META_COUNT)- POS(META_CV(ITER)))
	ENDDO
	DUMMY2 = DSQRT( DUMMY2 )
	!CHECKS CONDITION FOR DUMP
	IF( META_ITER .EQ. 0) THEN
		META_TRIGGER = .TRUE.
	ELSE IF( DUMMY1 .GE. META_TMAX ) THEN
		META_TRIGGER = .TRUE.
	ELSE IF( (DUMMY1 .GE. META_TMIN) .AND. (DUMMY2 .GT. WIDTH) ) THEN
		META_TRIGGER = .TRUE.
	ELSE
		META_TRIGGER = .FALSE.
	ENDIF
	RETURN
	END SUBROUTINE

	!SUBROUTINE *) DUMP
	!THIS SUBROUTINE ADDS A NEW GAUSSIAN WHEN THE CONDITION IS MET.
	SUBROUTINE DUMP
	USE PARAM
        USE UMBRSAMP
        USE DYNAMICS_MOLDYN
        USE CONSTANTS
        USE FORCEFIELD
        USE METADYN
        IMPLICIT NONE
	REAL*8 DUMMY
	INTEGER ITER1, ITER2
	!TRIGGERS HISTOGRAM GENERATION.
	IF ((UMBR .EQV. .TRUE. ).AND.(META_COUNT .EQ. META_NMAX)) THEN
		write(*,*) 'works'
		OPEN( UNIT =1, FILE = UMBR_FILENAME, STATUS = 'REPLACE' )
		CLOSE(1)
	ENDIF 
	IF( META_COUNT .LE. META_NMAX ) THEN 
	!INCREASES THE COUNT OF THE GAUSSIANS BY ONE.
		META_COUNT = META_COUNT + 1
	!UPDATES THE LAST STEP WHEN A NEW GAUSSIAN WAS ADDED.
		META_ITER = ITER_MOLDYN
	!STORES THE MEAN POSITION, WIDTH AND HEIGHT OF THE NEW GAUSSIAN.
		DO ITER1 = 1,META_DIM
			META_MEAN(ITER1,META_COUNT) = POS(META_CV(ITER1))
		ENDDO
		META_WIDTH(META_COUNT) = WIDTH
		CALL GET_META_HEIGHT 
		CALL GET_CT 
	!PRINTS THE INFORMATION IN THE RESTART FILE.
		IF( UMBR .EQV. .FALSE. ) 
     &		META_FILENAME = 'RESTART/RESTART_METDYN' 
		OPEN(UNIT=1, FILE=META_FILENAME, STATUS='OLD',
     &		POSITION = 'APPEND')
		IF(WELL_TEMP .EQV. .TRUE.) THEN
			 WRITE(1,*) ITER_MOLDYN, META_COUNT,
     &			(META_MEAN(ITER2, META_COUNT),
     &			ITER2=1,META_DIM),
     &			(1.0D0 +TEMP/DELTA_T)*META_HEIGHT(META_COUNT),
     &			META_WIDTH(META_COUNT), CT
		ELSE
			WRITE(1,*) ITER_MOLDYN, META_COUNT,
     &			(META_MEAN(ITER2, META_COUNT),
     &			ITER2=1,META_DIM),META_HEIGHT(META_COUNT),
     &			META_WIDTH(META_COUNT), CT
		ENDIF
		CLOSE(1)
	!PRINTS THE FREE ENERGY SURFACE.
		META_TRIGGER = .FALSE.
	ENDIF
	RETURN
	END SUBROUTINE 

	!SUBROUTINE *) GET_META_HEIGHT
	!THIS SUBROUTINE SCALES THE HEIGHT OF GAUSSIANS IN CASE OF WELL TEMPERED METADYNAMICS.
	SUBROUTINE GET_META_HEIGHT
        USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
        INTEGER ITER1, ITER2
        REAL*8 DUMMY
	IF( WELL_TEMP .EQV. .TRUE.) THEN
		META_HEIGHT(META_COUNT) = HEIGHT * DEXP( -V_BIAS / DELTA_T )
	ELSE
		META_HEIGHT(META_COUNT) = HEIGHT
	ENDIF
        RETURN
	END SUBROUTINE

	!SUBROUTINE *) GET_CT
	!THIS SUBROUTINE CALCULATES CT.
	SUBROUTINE GET_CT
        USE PARAM
        USE UMBRSAMP
        USE METADYN
        USE CONSTANTS
        USE FORCEFIELD
        USE DYNAMICS_MOLDYN
        IMPLICIT NONE
	REAL*8 GRID_POINT, GRID_DIF, DUMMY1
	REAL*8 NUM, DEN 
	INTEGER ITER1, ITER2, ITER3 
	!STARTING VALUE OF GRIDPOINT.
        GRID_POINT = GRID_MIN
	GRID_DIF = (GRID_MAX - GRID_MIN) / DFLOAT(NBINS-1)
        ITER3 = 1
	NUM = 0.0D0
	DEN = 0.0D0
	!OPENS THE OUTPUTFILE.
	OPEN(UNIT=1, FILE = 'OUTPUTFILES/FES', STATUS= 'UNKNOWN' )
        !STARTS THE CALCULATION
        DO
		DUMMY1 = 0.0D0
		ITER1 = META_COUNT-1
		DO ITER2=1,META_DIM
			DUMMY1 = DUMMY1 +
     &			( (GRID_POINT - META_MEAN(ITER2,ITER1)) *
     &			(GRID_POINT - META_MEAN(ITER2,ITER1)) )
		ENDDO
		DUMMY1 = DUMMY1 * 0.50D0 / META_WIDTH(ITER1) /
     &		META_WIDTH(ITER1)
	!CALCULATES THE TIME DEPENDENT BIAS.
		BIAS(ITER3) = BIAS(ITER3) +
     &		META_HEIGHT(ITER1) * DEXP( -DUMMY1 )
		IF (WELL_TEMP .EQV. .TRUE. ) THEN
			NUM = NUM + DEXP( (1.0D0 +TEMP/DELTA_T)*BIAS(ITER3)/TEMP )*
     &			GRID_DIF
			DEN = DEN + DEXP( (TEMP/DELTA_T)*BIAS(ITER3)/TEMP )*GRID_DIF
		ELSE 
			NUM = NUM + DEXP( BIAS(ITER3)/TEMP )*GRID_DIF
			DEN = DEN + GRID_DIF  
		ENDIF
	!INCREMENTATION.        
		GRID_POINT = GRID_POINT + GRID_DIF
		ITER3 = ITER3 + 1
	!ENDING VALUE OF GRIDPOINT. 
		IF( DABS(GRID_POINT-GRID_MAX) .LT. GRID_DIF/10.0 ) EXIT
	ENDDO
	!CALCULATES THE TIME DEPENDENT COSTANT.
		CT =  TEMP * DLOG(NUM / DEN)
	END SUBROUTINE
